# tests/test_lambda.fl

print("--- Testing Lambda Expressions ---")

let square = lambda x: x * x
print("square(5) =", square(5))

let add = lambda x, y: x + y
print("add(10, 20) =", add(10, 20))

let power = lambda x, n: x ** n
print("power(2, 10) =", power(2, 10))

# Lambda with closures
def make_adder(x):
    return lambda y: x + y

let add5 = make_adder(5)
print("add5(10) =", add5(10))

# Lambda in list comprehension
let nums = [1, 2, 3, 4, 5]
let callbacks = [lambda x: x * i for i in [1, 2, 3]]
# Note: due to common closure issues in many languages, i might be the same? 
# Let's see how Flux handles it.

print("Testing lambda with map-like behavior")
def map(f, items):
    return [f(item) for item in items]

let doubled = map(lambda x: x * 2, nums)
print("Doubled:", doubled)
